<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Développement</title>

<!-- Polices -->
<link href="https://fonts.googleapis.com/css2?family=Androgy+Demo&display=swap" rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=Mabry+Pro&display=swap" rel="stylesheet" />

<style>
:root {
  --primary: #3a86ff;
  --background: #f0f4f8;
  --text: #212529;
  --border-radius: 8px;
  --transition: 0.3s ease;
}

body {
  font-family: 'Mabry Pro', sans-serif;
  background: var(--background);
  color: var(--text);
  margin: 2rem;
  user-select: none;
  text-align: center;
}

h1 {
  font-family: 'Androgy Demo', sans-serif;
  text-transform: capitalize;
  color: var(--primary);
  margin-bottom: 1.5rem;
}

#expression {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  font-weight: bold;
}

#slots, #palette {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  justify-content: center;
  margin-bottom: 1.5rem;
}

.slot, .brick {
  padding: 0.75rem 1rem;
  min-width: 80px;
  border-radius: var(--border-radius);
  font-weight: bold;
  text-align: center;
  cursor: grab;
  transition: all var(--transition);
  user-select: none;
}

.slot {
  min-height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px dashed var(--primary);
  background: white;
  font-style: italic;
}

.slot.filled { 
  border-style: solid; 
  background-color: #d0e2ff; 
  font-style: normal; 
}

.brick {
  background: var(--primary);
  color: white;
  border: none;
  cursor: grab;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}
.brick.dragging { opacity: 0.5; cursor: grabbing; }
.brick:hover { transform: scale(1.05); }

#feedback {
  font-weight: bold;
  margin-bottom: 1rem;
  font-size: 1.2rem;
}
</style>
</head>
<body>

<h1>Développement</h1>

<div id="expression">a(x + b)</div>
<div id="slots"></div>
<div id="palette"></div>
<div id="feedback"></div>

<script>
const expressionEl = document.getElementById('expression');
const slotsEl = document.getElementById('slots');
const paletteEl = document.getElementById('palette');
const feedbackEl = document.getElementById('feedback');

let currentTerms = [];
let dragged = null;

// Générer question avec 2 termes et 5 choix avec pièges
function generateQuestion() {
  const a = Math.floor(Math.random()*5)+2;
  const b = Math.floor(Math.random()*5)+1;
  const sign = Math.random()<0.5?'+':'-';
  const expr = `${a}(x ${sign} ${b})`;
  const constTerm = sign==='+' ? a*b : -a*b;
  const terms = [`${a}x`, `${sign}${Math.abs(constTerm)}`];

  const choices = new Set();
  choices.add(`${a}x`);
  choices.add(`${sign}${Math.abs(constTerm)}`);
  while(choices.size < 5){
    const wrongSign = Math.random()<0.5 ? '+' : '-';
    const wrongVal = wrongSign==='+' ? a*b : -a*b;
    choices.add(`${wrongSign}${Math.abs(wrongVal)}`);
  }

  return {expr, terms, choices:[...choices].sort(()=>Math.random()-0.5)};
}

// Afficher la question
function renderQuestion() {
  const q = generateQuestion();
  currentTerms = q.terms;
  expressionEl.textContent = q.expr;
  slotsEl.innerHTML = '';
  paletteEl.innerHTML = '';
  feedbackEl.textContent = '';

  // Créer slots
  q.terms.forEach(term=>{
    const slot = document.createElement('div');
    slot.className='slot';
    slot.dataset.expect = term;
    slot.addEventListener('dragover', e=>e.preventDefault());
    slot.addEventListener('drop', onDrop);
    slotsEl.appendChild(slot);
  });

  // Créer palette
  q.choices.forEach(t=>{
    const brick = document.createElement('div');
    brick.className='brick';
    brick.textContent = t;
    brick.draggable = true;
    brick.addEventListener('dragstart', e=>{
      dragged = e.target;
      e.target.classList.add('dragging');
    });
    brick.addEventListener('dragend', e=>{
      e.target.classList.remove('dragging');
    });
    paletteEl.appendChild(brick);
  });
}

// Gérer dépôt dans slot
function onDrop(e){
  e.preventDefault();
  const slot = e.currentTarget;
  if(slot.firstChild){ paletteEl.appendChild(slot.firstChild); }
  slot.appendChild(dragged);
  slot.classList.add('filled');

  checkSlots();
}

// Vérifier slots et générer nouvelle question si correct
function checkSlots(){
  const slots = Array.from(slotsEl.children);
  let allCorrect = slots.every(slot => slot.firstChild && slot.firstChild.textContent === slot.dataset.expect);

  slots.forEach(slot=>{
    const actual = slot.firstChild ? slot.firstChild.textContent : null;
    if(actual === slot.dataset.expect){
      slot.style.borderColor = 'green';
    } else {
      slot.style.borderColor = 'red';
    }
  });

  if(allCorrect){
    feedbackEl.textContent = 'Bravo ! ✅ Nouvelle question...';
    setTimeout(renderQuestion, 1500);
  } else {
    feedbackEl.textContent = 'Vérifie les signes ❌';
  }
}

renderQuestion();
</script>

</body>
</html>
